# NEET Prep AI Platform - Development Rules

## Project Overview
Building a comprehensive AI-powered NEET preparation platform using a Turbo monorepo architecture with Next.js 14, React Native, TypeScript, Supabase, and the Vercel ecosystem.

## Architecture Principles

### Monorepo Structure
```
neet-prep-platform/
├── apps/
│   ├── web/                    # Main Next.js 14 web application
│   ├── mobile/                 # React Native + Expo mobile app
│   ├── admin/                  # Admin dashboard (Next.js)
│   └── coach/                  # Coach portal (Next.js)
├── packages/
│   ├── ui/                     # Shared UI components & design system
│   ├── database/               # Supabase client, types & queries
│   ├── ai/                     # AI services & prompt management
│   ├── auth/                   # Authentication logic & hooks
│   ├── analytics/              # Tracking, metrics & observability
│   ├── config/                 # Shared configurations & constants
│   ├── utils/                  # Common utilities & helpers
│   └── types/                  # Shared TypeScript types
├── tools/
│   ├── eslint-config/          # Shared ESLint configurations
│   └── tailwind-config/        # Shared Tailwind CSS config
└── docs/                       # Documentation & guides
```

## Technology Stack

### Core Technologies
- **Framework**: Next.js 14 (App Router, Server Components, Streaming)
- **Language**: TypeScript (strict mode enabled)
- **Styling**: Tailwind CSS + shadcn/ui components
- **Database**: Supabase (PostgreSQL + Auth + Realtime + Storage)
- **Monorepo**: Turbo
- **Package Manager**: npm workspaces
- **Mobile**: React Native + Expo
- **State Management**: Zustand
- **Server State**: TanStack Query
- **Forms**: React Hook Form + Zod validation
- **Animation**: Framer Motion

### Vercel Platform Services
- **AI SDK**: For AI/ML integration
- **Analytics**: Performance & usage analytics
- **KV**: Redis-compatible storage for caching
- **Blob**: File storage
- **Edge Functions**: Serverless compute
- **Speed Insights**: Performance monitoring

### External Services
- **AI**: OpenAI API (GPT-4o/Mini)
- **Payments**: Stripe
- **Communications**: Twilio (SMS)
- **Email**: SendGrid

## Development Rules

### 1. Code Quality Standards
- **TypeScript**: Always use strict mode (`"strict": true` in tsconfig.json)
- **No `any` types**: Use proper typing or `unknown` if type is truly unknown
- **Explicit return types**: All functions must have explicit return types
- **Const assertions**: Use `as const` for literal types
- **Null checks**: Always handle null/undefined cases explicitly

### 2. File Organization
- **Components**: One component per file, named same as component
- **Barrel exports**: Use index.ts files for clean imports
- **Colocation**: Keep related files together (component + styles + tests)
- **Feature folders**: Group by feature, not by file type

### 3. Naming Conventions
- **Components**: PascalCase (e.g., `QuizEngine.tsx`)
- **Utilities**: camelCase (e.g., `formatDate.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_RETRY_COUNT`)
- **Types/Interfaces**: PascalCase with descriptive names
- **File names**: kebab-case for non-components (e.g., `quiz-service.ts`)

### 4. API Development
- **Route handlers**: Use Next.js App Router API routes under `app/api/*`
- **Error handling**: Always return proper error responses with status codes
- **Type safety**: Share types between client and server via packages
- **Validation**: Use Zod for runtime validation
- **Rate limiting**: Implement rate limiting using Vercel KV

### 5. Database Guidelines
- **Supabase types**: Generate types using Supabase CLI
- **Row Level Security**: Always implement RLS policies
- **Migrations**: Track all schema changes via migrations
- **Query optimization**: Use proper indexes and avoid N+1 queries
- **Transactions**: Use database transactions for multi-step operations

### 6. Component Guidelines
- **Server Components**: Default to Server Components, use Client Components only when needed
- **Suspense boundaries**: Implement proper loading states
- **Error boundaries**: Wrap features in error boundaries
- **Accessibility**: Follow WCAG 2.1 AA standards
- **Responsive design**: Mobile-first approach

### 7. Testing Requirements
- **Unit tests**: For utilities and pure functions
- **Integration tests**: For API routes
- **E2E tests**: For critical user flows
- **Test coverage**: Minimum 70% coverage
- **Test naming**: Use descriptive test names that explain the scenario

### 8. Performance Rules
- **Bundle size**: Monitor and optimize bundle sizes
- **Code splitting**: Implement dynamic imports for large features
- **Image optimization**: Use Next.js Image component
- **Caching**: Implement proper caching strategies with Vercel KV
- **Database queries**: Optimize queries, use pagination

### 9. Security Standards
- **Authentication**: Use Supabase Auth with proper session management
- **Authorization**: Implement role-based access control (RBAC)
- **Input validation**: Always validate and sanitize user input
- **Secrets management**: Never commit secrets, use environment variables
- **CORS**: Configure proper CORS policies
- **Rate limiting**: Implement rate limiting on all API endpoints

### 10. Git Workflow
- **Branch naming**: `feature/description`, `fix/description`, `chore/description`
- **Commit messages**: Use conventional commits (e.g., `feat:`, `fix:`, `docs:`)
- **PR size**: Keep PRs small and focused (max 400 lines changed)
- **Code review**: All code must be reviewed before merging
- **CI/CD**: All tests must pass before merging

## Environment Variables

### Required Variables
```bash
# Supabase
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=

# OpenAI
OPENAI_API_KEY=

# Vercel KV
KV_REST_API_URL=
KV_REST_API_TOKEN=

# Stripe
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=

# Twilio
TWILIO_ACCOUNT_SID=
TWILIO_AUTH_TOKEN=
TWILIO_PHONE_NUMBER=

# SendGrid
SENDGRID_API_KEY=
```

### Development Setup
1. Copy `.env.example` to `.env.local`
2. Never commit `.env.local` or any file with real secrets
3. Use different env vars for development, staging, and production

## Build & Deployment

### Development Commands
```bash
# Install dependencies
npm install

# Start development servers
npm run dev

# Build all apps and packages
npm run build

# Run tests
npm run test

# Lint code
npm run lint

# Type check
npm run type-check

# Generate Supabase types
npm run db:generate

# Run database migrations
npm run db:migrate
```

### Deployment Process
1. **Staging**: Automatic deployment on push to `develop` branch
2. **Production**: Manual deployment after approval on `main` branch
3. **Preview**: Automatic preview deployments for all PRs
4. **Rollback**: Use Vercel dashboard for instant rollbacks

## AI Integration Guidelines

### Prompt Engineering
- Keep prompts focused and specific
- Include relevant context about student level
- Use structured output formats (JSON when possible)
- Implement prompt versioning for A/B testing
- Monitor token usage and costs

### AI Service Rules
- **Caching**: Cache AI responses in Vercel KV (24hr TTL for explanations)
- **Rate limiting**: Implement per-user rate limits
- **Fallbacks**: Always have fallback behavior if AI fails
- **Streaming**: Use streaming for long responses
- **Error handling**: Graceful degradation when AI services are unavailable

## Package Dependencies

### Adding Dependencies
- **Workspace packages**: Use `npm install package-name -w packages/package-name`
- **App dependencies**: Use `npm install package-name -w apps/app-name`
- **Root dependencies**: Only for build tools and dev dependencies
- **Version pinning**: Pin exact versions for critical dependencies

### Package Rules
- **No circular dependencies**: Packages cannot depend on each other circularly
- **Explicit exports**: All packages must have explicit exports in package.json
- **Type exports**: Always export TypeScript types alongside implementations
- **Documentation**: Each package must have its own README.md

## Monitoring & Observability

### Required Monitoring
- **Error tracking**: Sentry for error monitoring
- **Performance**: Vercel Analytics and Speed Insights
- **Uptime**: Use Vercel's built-in monitoring
- **Database**: Monitor query performance via Supabase dashboard
- **AI usage**: Track token usage and costs

### Logging Standards
- **Structured logging**: Use JSON format for logs
- **Log levels**: Use appropriate levels (error, warn, info, debug)
- **Sensitive data**: Never log passwords, tokens, or PII
- **Correlation IDs**: Include request IDs for tracing

## Mobile App Specific Rules

### React Native Guidelines
- **Expo managed workflow**: Use Expo for easier deployment
- **Platform-specific code**: Minimize platform-specific implementations
- **Navigation**: Use React Navigation v6
- **State management**: Share Zustand stores with web where possible
- **Offline support**: Implement offline-first features with AsyncStorage

## Documentation Requirements

### Code Documentation
- **JSDoc comments**: For all public APIs and complex functions
- **README files**: Each package and app must have a README
- **API documentation**: Use OpenAPI/Swagger for API docs
- **Architecture Decision Records**: Document significant decisions

## Performance Targets

### Web Vitals
- **LCP**: < 2.5 seconds
- **FID**: < 100 milliseconds
- **CLS**: < 0.1
- **TTFB**: < 600 milliseconds

### API Performance
- **Response time**: < 200ms for cached, < 1s for computed
- **Throughput**: Handle 1000+ concurrent users
- **Error rate**: < 0.1% error rate

## Development Phases

### Phase 1: Foundation (Current)
- Monorepo setup
- Core packages (config, database, auth, ui)
- Basic web app structure
- Database schema

### Phase 2: Core Features
- Question bank implementation
- Quiz engine
- AI explanation service
- User authentication

### Phase 3: Advanced Features
- Voice AI tutor
- AR question scanner
- Study groups
- Real-time features

### Phase 4: Enterprise
- Admin dashboard
- Analytics and metrics
- Payment integration
- Coach portal

### Phase 5: Optimization
- Performance optimization
- Caching layer
- Real-time sync
- Offline support

### Phase 6: Production
- Monitoring setup
- Deployment pipeline
- Documentation
- Multi-exam support

## Contact & Support

For questions about these rules or the project architecture, consult the design document: `NEET Prep AI Platform - Comprehensive System Design.md`

---

**Remember**: 
- Always prioritize type safety and code quality
- Keep the codebase maintainable and scalable
- Follow the established patterns consistently
- Document your decisions and changes
- Test your code thoroughly before committing
